#동전
#dp
#https://www.acmicpc.net/problem/9084

t = int(input())
for _ in range(t):
    # 동전 가지 수 n
    n = int(input())
    # n가지 동전의 금액 리스트 coins
    coins = list(map(int, input().split()))
    # 만들어야 할 금액 m
    want = int(input())
    
    #dp[i] 배열은 i원을 만드는 경우의 수를 저장하는 배열
    dp = [0 for _ in range(want + 1)]
    dp[0] = 1
    for coin in coins:
        for index in range(1, want + 1):
            if index - coin >= 0:
                # 이전 동전으로 만든 경우의 수를 계속 더해나가면서 배열을 저장해나간다.
                dp[index] += dp[index - coin]
    print(dp[want])

#https://m.blog.naver.com/PostView.nhn?blogId=occidere&logNo=220793012348&proxyReferer=https:%2F%2Fwww.google.com%2F
"""
이전번째 동전을 사용하는 경우를 포함해 주어야 한다는 것이다. 따라서 점화식을 세울 때, 예전의 동전으로 만든 경우의 수에 계속 더해나가야만 이를 반영할 수 있다.
좀더 쉽게 얘기 해 보자. 동전이 3개(a[1], a[2], a[3])가 있다. 목표금액은 10이다. d[i] 배열은 i원을 만드는 경우의 수 를 저장하는 배열이다.
  (1) 1번째 동전으로 10원까지 채우는 경우의 수를 계산해 d[i] 배열에 누적해 저장한다.
  (2) 2번째 동전으로 10원까지 채우는 경우의 수를 계산해 d[i] 배열에 누적해 저장한다.
  (3) 3번째 동전으로 10원까지 채우는 경우의 수를 계산해 d[i] 배열에 누적해 저장한다.

이 과정을 순서대로 하면 1번째 동전으로 만드는 경우의 수 + 2번째 동전으로 만드는 경우의 수 + 3번째 동전으로 만드는 경우의 수 가 되어 
결국 모든 동전을 다 사용하여 만드는 경우의 수가 되는 것이다.

이제 마지막 하나만 더 고려를 해보자. 
m원까지 만드는 경우의 수를 고려하는 과정에서 주어진 동전의 금액보다 적은 경우 굳이 고려를 해줄 필요가 있을까? 
예를들어 3원짜리로 10원까지 만드는데 1, 2원을 만드는 경우를 생각할 필요가 있느냐 이다. 
어차피 자기 액면가보다 작은 경우 만드는 것 자체가 불가능하기 때문에 비교 시작점을 해당 동전의 금액인 a[i]원으로 잡으면 되는 것이다.
"""